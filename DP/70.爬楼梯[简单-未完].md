# 爬楼梯

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/climbing-stairs

## 题目

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶
>
> 

示例 2：

> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶

## 解答

### 暴力递归

定义一个$climbStair(i,n)$函数，其中$i$表示当前阶数，$n$表示总阶数，如果$i=n$就返回1，如果$i>n$就返回零。我们将会把所有可能爬的阶数进行组合，也就是 1 和 2 。而在每一步中我们都会继续调用$climbStair(i,n)$这个函数模拟爬 1 阶和 2 阶的情形，并返回两个函数的返回值之和。

$$
climbStair(i,n)=climbStair(i+1,n)+climbStair(i+2,n)
$$

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        return self.climb_stairs(0,n)
    def climb_stairs(self,i,n):
        if (i > n):
            return 0
        if (i == n):
            return 1
        return self.climb_stairs(i + 1, n) + self.climb_stairs(i + 2, n)
```

#### 复杂度分析

* 时间复杂度

  $O(2^n)$，树形递归的大小为$2^n$

  在 n = 5 时的递归树将是这样的：

  <img src="figs/70_1.png" alt="70_1" style="zoom:50%;" />

* 空间复杂度

  $O(n)$，树形递归的深度可达到$n$

这种解法会超时！！！

### 记忆化递归

在上面的方法中，我们计算每一步的结果时出现了冗余，比如第3步中出现了两个(3,5)。另一种思路是，我们可以把每一步的结果存储在 memo数组之中，每当函数再次被调用，我们就直接从memo数组返回结果。

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        memo=[0]*(n+1)
        return self.climb_stairs(0,n, memo)
    def climb_stairs(self,i,n,memo):
        if i > n:
            return 0
        if i == n:
            return 1
        if memo[i] > 0:
            return memo[i]
        memo[i]=self.climb_stairs(i + 1, n,memo) + self.climb_stairs(i + 2, n,memo)
        return memo[i]
```

#### 复杂度分析

* 时间复杂度

  $O(n)$，树形递归的大小可达到$n$

* 空间复杂度

  $O(n)$，树形递归的深度可达到$n$

### 动态规划

