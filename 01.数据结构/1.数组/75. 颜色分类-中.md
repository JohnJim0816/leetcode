#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。



 

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**示例 3：**

```
输入：nums = [0]
输出：[0]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

 

**进阶：**

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？



本问题被称为荷兰国旗问题，解题思路类似于快排的三路取中法。
即使用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。

## 伪代码


>* 初始化0的最右边界：`p0 = 0`
>* 初始化2的最左边界 ：`p2 = n - 1`
>* 初始化当前元素序号 ：`curr = 0`
>* **WHILE** `curr <= p2`:
>    * IF `nums[curr] = 0` ：交换第 `curr`个 和 第`p0`个 元素; curr++;p0++
>    * IF `nums[curr] = 2` ：交换第 `curr`个和第 `p2`个元素;p2++ 
>    * 若 `nums[curr] = 1` ：curr++

注意一个状态维持的关键说明：

> curr 左边全都是0/1的有序序列！
> 1. curr位置是0时，与左边的0位置交换，因为保证curr左边全是0/1, 所以交换过来的必然是0/1，状态维持住了；
> 2. curr位置是2时，交换后，curr不能移动，因为一移动，没法保证交换过来的是0/1；所以这里不移动；这时状态也维持住了
> 只要我们保证curr左边的都是0,1，才移动，那么0都被放到左边，2都被放到右边，中间自然是1了； 综上，这是一个关键状态说明，有了这个说明，逻辑才更加清楚

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        '''
        荷兰三色旗问题解
        '''
        # 对于所有 idx < p0 : nums[idx < p0] = 0
        # curr是当前考虑元素的下标
        p0 = curr = 0
        # 对于所有 idx > p2 : nums[idx > p2] = 2
        p2 = len(nums) - 1

        while curr <= p2:
            if nums[curr] == 0:
                nums[p0], nums[curr] = nums[curr], nums[p0]
                p0 += 1
                curr += 1
            elif nums[curr] == 2:
                nums[curr], nums[p2] = nums[p2], nums[curr]
                p2 -= 1
            else:
                curr += 1
```

