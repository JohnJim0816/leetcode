# [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用0来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温列表长度的范围是[1,30000]。每个气温的值的均为华氏度，都是在 [30,100]范围内的整数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/daily-temperatures
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 暴力解法     

即嵌套循环，外循环遍历温度表T，对于每个T[i]，再遍历T[i+1],T[i+2],..,T[-1], 找出最近的高温度位置即可。代码略。
对于T= [73, 74, 75, 71, 69, 72, 76, 73], 对于T[0]=73，从T[1]=74再开始遍历查找，得到最近的高温度为T[1]，所以ans[0]=1，依次类推。
时间复杂度：O(N(N-1)/2+1)，N为给定的T元素个数
空间复杂度：O(N)

## 解法二

采用逆序遍历温度列表，因为是要用后面的温度与当前温度做比较，顺序的话每次都要查找后面的温度，而逆序的话只需要遍历一遍将后面的温度值储存起来就行。
然后因为可选的温度列表只在[30,100]，所以使用next数组记录，30-100作为index，对应温度的序数作为值就行。这里还利用到一点，就是对于相同的温度值，逆序遍历的时候只需要保存最低的序数，即最早出现该温度的天数，比如T[2]=70,T[4]=70,逆序遍历到2的时候保存nxt[70]=2即可。
然后使用warmer_index记录比当前温度高的索引位置，它等于 next[T[i]+1], next[T[i]+2], ..., next[100] 的最小值，则答案等于warmer_index-当前的遍历序数。
程序见"daily_temperatures_1.py"
前面遍历各值如下：
i=7 warmer_index=inf ans[7]=0 nxt[73]=7
i=6 warmer_index=inf ans[6]=0 nxt[76]=6
i=5 warmer_index=6   ans[5]=1 nxt[72]=5

```python
class Solution():
    def dailyTemperatures(self, T):
        nxt = [float('inf')] * 102
        ans = [0] * len(T)
        for i in range(len(T) - 1, -1, -1):
            #Use 102 so min(nxt[t]) has a default value
            warmer_index = min(nxt[t] for t in range(T[i]+1, 102))
            print(warmer_index)
            if warmer_index < float('inf'):
                ans[i] = warmer_index - i
            nxt[T[i]] = i
        return ans
```



## 栈

TODO 